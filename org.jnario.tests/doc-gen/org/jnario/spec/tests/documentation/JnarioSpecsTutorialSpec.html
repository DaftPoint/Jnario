<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Jnario Specs - Tutorial</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Le styles -->
<link rel="stylesheet" href="../../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../../css/custom.css">
<link rel="stylesheet" href="../../../../../css/prettify.css">
<script type="text/javascript" src="../../../../../js/prettify.js"></script>
<script type="text/javascript" src="../../../../../js/lang-jnario.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="content">
			<div class="page-header">
				<h1>Jnario Specs - Tutorial</h1>
			</div>
			<div class="row">
				<div class="span12">
<p>This tutorial gives you an introduction on how to write unit specifications with Jnario. Jnario Specs is based on <a href="http://www.xtend-lang.org">Xtend</a> and it might be a good idea to read the Xtend <a href="http://www.eclipse.org/xtend/documentation/index.html">documentation</a> before you get started with Jnario, because expressions, fields, methods and extensions in Jnario work exactly as in Xtend.</p><h3>Installation &amp; Runtime Library</h3><p>Jnario currently requires <a href="http://www.eclipse.org">Eclipse</a> 3.5 or higher with <a href="http://www.xtext.org">Xtext</a> 2.3, and a Java SDK version 5 or above. You can install the most recent version from this update site: <code>http://www.jnario.org/updates/snapshot/</code>. Jnario requires a small runtime library that contains the JUnit integration. You can download the jar <a href="http://jnario.org/updates/snapshot/org.jnario.lib-0.1.0-SNAPSHOT.jar">here</a>.</p>
<h3>How to write a Specification</h3>
<p><p>To get started create a new specification using the spec wizard (<strong>File</strong> -&gt; <strong>New</strong> -&gt; <strong>Other</strong> -&gt; <strong>Jnario</strong> -&gt; <strong>Spec</strong>).</p>
<p align="center"><img src="/img/tutorial/spec_wizard.png" alt="New Spec Wizard"/></p><p>In Jnario we <em>describe facts</em> about our program. For example, here are two simple facts of a stack:</p>
<pre class="prettyprint lang-jnario">
describe "A Stack"{
  fact "initial size is 0"
  fact "increases its size when pushing an element"
}
</pre><p>To execute this specification, right click in the editor and select <strong>Run As</strong> -&gt; <strong>JUnit Test</strong>. The specification will pass, but the facts in our specification will be marked as <em>PENDING</em> as they are not implemented yet.</p>
<pre>A Stack
  - initial size is 0 [PENDING]
  - increases its size when pushing an element [PENDING]
</pre><p>In the background, Jnario automatically translates our stack specification into a JUnit test case <code>AStackSpec.java</code>. You can find it in the <code>xtend-gen</code>folder.</p>
</p>
<ul><li><p>
<strong>Checking your facts</strong>
<p>The next step is to enrich our facts with the required logic to check whether our stack behaves as specified. Checks are implemented by adding a block expression to your facts We use <code>=&gt;</code> to describe the expected result of a expression. For example, <code>new Stack.size =&gt; 0</code> will fail if the size is not <code>0</code>. If we execute our specification we will see that all specifications pass and that they are not marked as <em>PENDING</em> anymore,</p><p><span class="label label-info">Info</span> Declaring and importing other packages works similar to Xtend (static imports work as well).</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  fact "initial size is 0" {
    new Stack().size =&gt; 0
  }
  fact "increases its size when pushing an element"{
    val subject = new Stack
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li><li><p>
<strong>Less boilerplate</strong>
<p>If we look at our first fact:</p>
<pre class="prettyprint lang-jnario">
describe "A Stack"{
  fact "initial size is 0" {
   new Stack().size => 0
 }
 // ...
}
</pre><p>we see that the string description looks pretty similar to the actual code. We can make this even more obvious by replacing <code>new Stack().size =&gt; 0</code> with <code>new Stack().size should be 0</code>, using the more descriptive <code>should be</code> assertion Â“instead of <code>=&gt;</code>. In Jnario you can avoid such redundancies between code and description by leaving the description out. The code becomes the actual description:</p>
<pre>A Stack
  - new Stack().size should be 0
  - increases its size when pushing an element</pre><p><span class="label label-important">Important</span> Facts without description can only have a single statement. If you need more statements, you should add a description.</p><p>Here is the updated version of our specification:</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  fact new Stack().size should be 0
  fact "increases its size when pushing an element"{
    val subject = new Stack
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li><li><p>
<strong>Using Fields</strong>
<p>In the previous specification we have a little redundancy: the creation of the Stack. We can get rid of it by creating a field for the Stack. Declaring fields works exactly as in <a href="http://www.eclipse.org/xtend/documentation/index.html#fields">Xtend</a>.</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  Stack subject = new Stack
  fact "initially empty" {
    subject.size =&gt; 0
  }
  fact "increases its size when pushing an element"{
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li><li><p>
<strong>Implicit Subjects</strong>
<p>In our example we specify the behavior of a single class, which is actually a common use case. Jnario you can directly reference the specified class in the describe clause:</p>
<pre class="prettyprint">package demo

import java.util.Stack

describe Stack{
  ...
}
</code></pre><p>This way you achieve a strong link between specification and its target that works even if the target class is renamed. Jnario will also implicitly create a field called <code>subject</code> of the target type (<a href="/org/jnario/spec/tests/documentation/ImplicitSubject.html">more...</a>). Therefore we can get rid of the subject field in our stack specification.</p><p><span class="label label-important">Important</span> The implicit subject works only if the target class has a default constructor without any arguments, but it is also possible to use Guice or other frameworks to automatically create the subjects (<a href="/org/jnario/spec/tests/documentation/SpecInstantiation.html">more...</a>).</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe Stack{
  fact subject.size should be 0
  fact "increases its size when pushing an element"{
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li><li><p>
<strong>Defining Contexts</strong>
<p>Sometimes a class behaves differently in different contexts. For example, the behavior when calling pop on a stack depends on whether the stack empty or not. You can define contexts within Jnario specs to further structure your facts:</p>
<pre class="prettyprint">Stack
  when empty
    - subject.size =&gt; 0
    - subject.pop throws EmptyStackException
  with elements
    - pop decreases size
    - pop removes last element&quot;
</code></pre><p>In this example we also use the <code>throws</code> statement in <code>subject.pop throws EmptyStackException</code>. It fails if the previous statement does not throw an instance of the specified exception.</p>
<pre class="prettyprint lang-jnario">
package demo
	      
import java.util.Stack
import java.util.EmptyStackException

describe Stack{
  context "when empty"{
    fact subject.size =&gt; 0
    fact subject.pop throws EmptyStackException
  }
  context "with elements"{
    before subject.add("a element")
    fact "pop decreases size"{
      subject.pop
      subject.size =&gt; 0
    }	
    fact "pop removes last element"{
      subject.pop =&gt; "a element"
    }		
  }
}</pre>
</p>
</li><li><p>
<strong>Example Tables</strong>
<p>You can structure your example data in tables. The type of each column will be automatically inferred from all column values. A cell in a table can have an arbitrary non-void expression as a value. You can perform assertions on tables using the <code>forEach</code> extension method:</p>
<pre class="prettyprint lang-jnario">
describe "Addition" {
  def additions{
    | a | b | sum |
    | 0 | 0 |  0  |
    | 1 | 2 |  3  |
    | 4 | 5 |  9  |
 }
 fact additions.forEach[a + b should be sum]
}
</pre><p>The <code>forEach</code> extension method expects a closure as argument. Within the closure you can directly access all values in a row by their column name. The great thing about example tables is that they will give you detailed error messages when one of the assertions fails (<a href="/org/jnario/spec/tests/documentation/ExampleTables">more...</a>):</p>
<pre class="prettyprint">java.lang.AssertionError: additions failed

        | a     | b     | sum     |
        | 0     | 0     | 0       | OK
        | 1     | 2     | 4       | FAILED     (1)
        | 4     | 5     | 9       | OK

(1) Expected a + b should be sum but:
         a + b is 3
         a is 1
         b is 2
         sum is 4
</code></pre>
</p>
</li><li><p>
<strong>Setup & Teardown</strong>
<p>Setting up a fixture or tearing it down works similar to JUnit, but the syntax is less verbose. The following specification will print:</p>
<pre class="prettyprint">before all
before
do stuff
after
before
do more stuff
after
after all
</code></pre>
<pre class="prettyprint lang-jnario">
describe "Setup & Teardown" {
  before all{
    println("before all")
  }  
  before{
    println("before")
  }
  fact "should do stuff" {
    println("do stuff")
  }
  fact "should do more stuff" {
    println("do more stuff")
  }
  after{
    println("after")
  }
  after all{
    println("after all")
  }
}</pre>
</p>
</li><li><p>
<strong>Spec extensions</strong>
<p>When you have to perform the same setup and tear down operations for different specs you can use spec extensions. For example, we need to open and close a database connection before and after each test case. With Jnario you can encapsulate these operations into a separate class and use the normal JUnit @before and @after annotations to mark the methods that should be executed before and after a spec run.</p>
<pre class="prettyprint">package demo

import org.junit.Before
import org.junit.After

class DatabaseExtension {
  @Before
  def void openDatabaseConnection(){
    println(&quot;openDatabaseConnection&quot;)
  }
  def query(String statement){
    println(&quot;query: &quot; + statement)
  }
  @After
  def void closeDatabaseConnection(){
    println(&quot;closeDatabaseConnection&quot;)
  }
}
</code></pre><p>If we create an <a href="http://www.eclipse.org/xtend/documentation/index.html#Extension_Fields">extension field</a> for our database helper class within our spec:</p>
<pre class="prettyprint">extension DatabaseExtension db = new DatabaseExtension
</code></pre><p>the setup and tear down methods will be automatically executed with the additional benefit that we can directly access all methods in your database extension without the field name.</p>
<pre class="prettyprint">openDatabaseConnection
query: SELECT * FROM content
closeDatabaseConnection
</code></pre>
<pre class="prettyprint lang-jnario">
describe "Spec Extensions"{
	extension DatabaseExtension db = new DatabaseExtension
	fact query("SELECT * FROM content")	      
}</pre>
</p>
</li><li><p>
<strong>Helper methods</strong>
<p>Helper methods can be directly declared in Jnario files. They have the same syntax as in Xtend. Helper methods and fields can also be defined in nested contexts.</p>
<pre class="prettyprint lang-jnario">
describe "Helper Methods & Fields"{
  String subject = "World" 
  fact "can access fields and methods"{
    subject.greeting =&gt; "Hello World"
  }
  def greeting(String s){
    return "Hello " + s
  }
  context "shouting"{
    String emphasize = "!" 
    fact "can access fields and methods from parent"{
       subject.greeting.shout =&gt; "HELLO WORLD!"
    }
    def shout(String s){
      return s.toUpperCase + emphasize
    }
  }
}</pre>
</p>
</li></ul>
<h3>Writing Assertions</h3>
<p><p>Jnario provides different statements for writing assertions (<a href="/org/jnario/spec/tests/documentation/Assertion.html">more...</a>).</p>
</p>
<ul><li><p>
<strong>'assert'</strong>
<p>The <code>assert</code> statement fails if the following expression does not evaluate to <code>true</code>.</p>
<pre class="prettyprint lang-jnario">
assert true
assert new Stack().empty
assert "Hello".startsWith("H")</pre>
</p>
</li><li><p>
<strong>'should', 'must' and `=>`</strong>
<p>If you want to express how an object should behave, you can use <code>should</code> or <code>must</code>. It passes if the result of the left expression is equal to the result of the right expression. You can also use <code>not</code> to assert that both expressions have different results. You have already seen the short cut <code>=&gt;</code> which has the same effect as <code>should be</code>.</p>
<pre class="prettyprint lang-jnario">
true should be true
"hello" must be "hello"
1 + 1 should not be 1 
"hello".toUpperCase must not be "hello"
1 + 1 =&gt; 2</pre>
</p>
</li><li><p>
<strong>Self-explaining failures</strong>
<p>Assertions in Jnario are self-explainable. When an assertion fails, it tries to provide as as much information as possible. It will print the exact expression that has failed together with the actual value of all subexpressions. This means that you don't need to debug a test to see why it actually has failed.</p>
<pre class="prettyprint lang-jnario">
val x = 0 
val y = 1 
errorMessage[assert x == 1 && y == 0].is('''
  Expected x == 1 && y == 0 but:
       x == 1 is false
       x is 0
       y == 0 is false
       y is 1''')
       
val greeting = "hello"        
errorMessage[greeting.toUpperCase should not be "HELLO"].is('''
  Expected x.toUpperCase should not be "HELLO" but:
     x.toUpperCase is "HELLO"
     x is "hello"''')</pre>
</p>
</li></ul>
				</div>
			</div>
		</div> <!-- /content -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>

	</div>
	<!-- /container -->

</body>
</html>
