/*
 * generated by Xtext
 */
package de.bmw.carit.jnario.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import com.google.common.collect.Iterators

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.xbase.compiler.*
import org.eclipse.xtext.xbase.*
import de.bmw.carit.jnario.jnario.*
import org.eclipse.xtext.common.types.*
import java.util.*
import com.google.inject.Inject
import static extension org.eclipse.xtext.xtend2.lib.ResourceExtensions.*
import org.eclipse.xtext.xtend2.lib.StringConcatenation

class JnarioGenerator implements IGenerator {
	
	@Inject JnarioCompiler jnarioCompiler
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		
		for(feature: resource.allContentsIterable.filter(typeof(Jnario))) {
						
			var className = feature.name
			className = className.replaceAll("[^A-Za-z0-9_]","");
			fsa.generateFile(className + ".java", feature.compile(className))
		}
	}
	
	def compile(Jnario spec, String className) '''
		«val importManager = new ImportManager(true)»
		«steps(spec, importManager, className)»
	'''
	
	def steps(Jnario feature, ImportManager importManager, String className) '''
		import org.junit.Test;
		
		public class «className»{
			«FOR s:feature.scenarios»
			
				@Test
				public void «s.name.extractName»(){
				«jnarioCompiler.initializeStringBuilder(importManager)»
				«FOR givenCode: s.given.code»
					«IF(givenCode != null)»
						«jnarioCompiler.compile(givenCode)»
					«ENDIF»
				«ENDFOR»
				«FOR whenCode: s.when.code»
					«IF(whenCode != null)»
						«jnarioCompiler.compile(whenCode)»
					«ENDIF»
				«ENDFOR»
				«FOR thenCode: s.then.code»
					«IF(thenCode != null)»
						«jnarioCompiler.compile(thenCode)»
					«ENDIF»
				«ENDFOR»
				}
			«ENDFOR»
		}
	'''
	
//	def createMethods(String name, List<XBlockExpression> code){
//		
//	}
//
//	
//	def given(Given given, String givenName, ImportManager importManager)'''
//			public void «givenName»(){
//				«jnarioCompiler.compile(given.code, importManager)»
//			}
//	'''
//// TODO: extract method, as parameter when/then
//// how to treat AND? multiple method calls one after the other?
//	def when(When when, String whenName, ImportManager importManager)'''
//			private void «whenName»(){
//				«jnarioCompiler.compile(when.code, importManager)» 
//			}
//	'''
//	
//	def then(Then then, String thenName, ImportManager importManager)'''
//			private void «thenName»(){
//				«jnarioCompiler.compile(then.code, importManager)» 
//			}
//	'''
	
	def extractName(String name){
		var methodName = ""
		var words = name.split(' ');
		for(word: words){
			var upperWord = word.toFirstUpper
			methodName = methodName + upperWord
		}
		
		// TODO: new line wegschneiden
		var indexOfSentenceEnd = methodName.lastIndexOf(".")
		if(indexOfSentenceEnd > -1){
			methodName = methodName.substring(0, indexOfSentenceEnd);
		}
		methodName = methodName.toFirstLower
		methodName = methodName.replaceAll("[^A-Za-z0-9_]","");
		return methodName
	}
}
