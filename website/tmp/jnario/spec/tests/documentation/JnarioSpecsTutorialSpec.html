<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Jnario Specs - Tutorial</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Le styles -->
<link rel="stylesheet" href="../../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../../css/custom.css">
<link rel="stylesheet" href="../../../../../css/prettify.css">
<script type="text/javascript" src="../../../../../js/prettify.js"></script>
<script type="text/javascript" src="../../../../../js/lang-jnario.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="content">
			<div class="page-header">
				<h1>Jnario Specs - Tutorial</h1>
			</div>
			<div class="row">
				<div class="span12">
<p><p>This tutorial gives you an introduction on how to write unit specifications with Jnario. Jnario Specs is based on <a href="http://www.xtend-lang.org">Xtend</a> and it might be a good idea to read the Xtend <a href="http://www.eclipse.org/xtend/documentation/index.html">documentation</a> before you get started with Jnario, because expressions, fields, methods and extensions in Jnario work exactly as in Xtend.</p><h3>Installation &amp; Runtime Library</h3><p>Jnario currently requires <a href="http://www.eclipse.org">Eclipse</a> 3.5 or higher with <a href="http://www.xtext.org">Xtext</a> 2.3, and a Java SDK version 5 or above. You can install the most recent version from this update site: <code>http://www.jnario.org/updates/snapshot/</code>. Jnario requires a small runtime library that contains the JUnit integration. You can download the jar <a href="http://jnario.org/updates/snapshot/org.jnario.lib-0.1.0-SNAPSHOT.jar">here</a>.</p>
</p>
<ul>
<li><h3>How to write a Specification</h3>
<p><p>To get started create a new specification using the spec wizard (<strong>File</strong> -&gt; <strong>New</strong> -&gt; <strong>Other</strong> -&gt; <strong>Jnario</strong> -&gt; <strong>Spec</strong>).</p>
<p align="center"><img src="/img/tutorial/spec_wizard.png" alt="New Spec Wizard"/></p><p>In Jnario we <em>describe facts</em> about our program. Here are two simple facts of a stack:</p>
<pre class="prettyprint">describe &quot;A Stack&quot;{
  fact &quot;initial size is 0&quot;
  fact &quot;increases its size when pushing an element&quot;
}
</code></pre><p>To execute this specification, right click in the editor and select <strong>Run As</strong> -&gt; <strong>JUnit Test</strong>. The specification will pass, but the facts in our specification will be marked as <em>PENDING</em> as they are not implemented yet.</p>
<pre>A Stack
  - initial size is 0 [PENDING]
  - increases its size when pushing an element [PENDING]
</pre>
</p>
<ul>
<li><strong>Checking your facts</strong>
<p>
<p>The next step is to enrich our facts with the required logic to check whether our stack behaves as specified by adding a block expression to your facts We use <code>=&gt;</code> to describe the expected result of a expression. For example, <code>new Stack.size =&gt; 0</code> will fail if the size is not <code>0</code>. If we execute our specification we will see that all specifications pass and that they are not marked as <em>PENDING</em> anymore,</p><p><span class="label label-info">Info</span> Declaring and importing other packages works similar to Xtend (static imports work as well).</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  fact "initial size is 0" {
    new Stack().size =&gt; 0
  }
  fact "increases its size when pushing an element"{
    val subject = new Stack
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li>
<li><strong>Less boilerplate</strong>
<p>
<p>If we look at our first fact:</p>
<pre class="prettyprint">describe &quot;A Stack&quot;{
  fact &quot;initial size is 0&quot; {
        new Stack().size =&gt; 0
  }
  // ...
}
</code></pre><p>we see that the string description looks pretty similar to the actual code. We can make this even more obvious by replacing <code>new Stack().size =&gt; 0</code> with <code>new Stack().size should be 0</code>, using the more descriptive <code>should be</code> assertion Â“instead of <code>=&gt;</code>. In Jnario you can avoid such redundancies between code and description by leaving the description out. The code becomes the actual description:</p>
<pre>A Stack
  - new Stack().size should be 0
  - increases its size when pushing an element</pre><p><span class="label label-important">Important</span> Facts without description can only have a single statement. If you need more statements, you should add a description.</p><p>Here is the updated version of our specification:</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  fact new Stack().size should be 0
  fact "increases its size when pushing an element"{
    val subject = new Stack
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li>
<li><strong>Using Fields</strong>
<p>
<p>In the previous specification we have a little redundancy: the creation of the Stack. We can get rid of it by creating a field for the Stack. Declaring fields works exactly as in <a href="http://www.eclipse.org/xtend/documentation/index.html#fields">Xtend</a>.</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe "A Stack"{
  Stack subject = new Stack
  fact "initially empty" {
    subject.size =&gt; 0
  }
  fact "increases its size when pushing an element"{
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li>
<li><strong>Implicit Subjects</strong>
<p>
<p>In our example we specify the behavior of a single class, which is actually a common use case. Jnario you can directly reference the specified class in the describe clause:</p>
<pre class="prettyprint">package demo

import java.util.Stack

describe Stack{
  ...
}
</code></pre><p>This way you achieve a strong link between specification and its target that works even if the target class is renamed. Jnario will also implicitly create a field called <code>subject</code> of the target type. Therefore we can get rid of the subject field in our stack specification.</p><p><span class="label label-important">Important</span> The implicit subject works only if the target class has a default constructor without any arguments, but it is also possible to use Guice or other frameworks to automatically create the subjects (<a href="/documentation/snapshot/ImplicitSubject.html">more...</a>).</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.Stack

describe Stack{
  fact subject.size should be 0
  fact "increases its size when pushing an element"{
    subject.push("A String")
    subject.size =&gt; 1
  }
}</pre>
</p>
</li>
<li><strong>Hierarchical Specifications</strong>
<p>
<p>Sometimes a class behaves differently in different contexts.</p>
<pre class="prettyprint lang-jnario">
package demo

import java.util.*

describe Stack{
  context "empty"{
    fact subject.size =&gt; 0;
    fact subject.pop throws EmptyStackException;
  }
  context "adding elements"{
    fact "increases size"{
      subject.push("A String")
      subject.size =&gt; 1
    }		
  }
}</pre>
</p>
</li>
<li><strong>Setup & Teardown</strong>
<p>
<p>The following specification will print:</p>
<pre class="prettyprint">before all
before
do stuff
after
before
do more stuff
after
after all
</code></pre>
<pre class="prettyprint lang-jnario">
describe "Setup & Teardown" {
  before all{
    println("before all")
  }  
  before{
    println("before")
  }
  fact "should do stuff" {
    println("do stuff")
  }
  fact "should do more stuff" {
    println("do more stuff")
  }
  after{
    println("after")
  }
  after all{
    println("after all")
  }
}</pre>
</p>
</li>
<li><strong>Helper methods</strong>
<p>
<pre class="prettyprint lang-jnario">
describe "Helper Methods & Fields"{

  String subject = "World" 

  fact "can access fields and methods"{
    subject.greeting =&gt; "Hello World"
  }
  
  def greeting(String s){
    return "Hello " + s
  }

  context "shouting"{
    
    fact "can access fields and methods from parent"{
       subject.greeting.shout =&gt; "HELLO WORLD"
    }
    
    def shout(String s){
      return s.toUpperCase
    }
  }
}</pre>
</p>
</li>
</ul>
</li>
<li><h3>Writing Assertions</h3>
<p><p>Jnario provides different ways to write assertions.</p>
</p>
<ul>
<li><strong>'assert'</strong>
<p>
<p>Jnario provides a special <code>assert</code> statement, which fails if the following expression does not evaluate to <code>true</code>.</p>
<pre class="prettyprint lang-jnario">
assert true
assert new Stack().empty
assert "Hello".startsWith("H")</pre>
</p>
</li>
<li><strong>'should', 'must' and `=>`</strong>
<p>
<p>If you want to express how an object should behave, you can use <code>should</code> or <code>must</code>. It passes if the result of the left expression is equal to the result of the right expression. You can also use <code>not</code> to assert that both expressions have different results. You have already seen the short cut <code>=&gt;</code> which has the same effect as <code>should be</code>.</p>
<pre class="prettyprint lang-jnario">
true should be true
"hello" must be "hello"
1 + 1 should not be 1 
"hello".toUpperCase must not be "hello"
1 + 1 =&gt; 2</pre>
</p>
</li>
<li><strong>Self-explaining failures</strong>
<p>
<p>Assertions in Jnario are self-explainable. When an assertion fails, it tries to provide as as much information as possible. They print the exact expression that has failed together with the actual value of all subexpressions. This means that you don't need to debug a test to see why it actually has failed.</p>
<pre class="prettyprint lang-jnario">
val x = 0 
val y = 1 
errorMessage[assert x == 1 && y == 0].is('''
  Expected x == 1 && y == 0 but:
       x == 1 is false
       x is 0
       y == 0 is false
       y is 1''')
       
val greeting = "hello"        
errorMessage[greeting.toUpperCase should not be "HELLO"].is('''
  Expected x.toUpperCase should not be "HELLO" but:
     x.toUpperCase is "HELLO"
     x is "hello"''')</pre>
</p>
</li>
<li><strong>Expecting Exceptions</strong>
<p>
<p>There are two ways on how to check whether an expression is thrown. The first one is to declare the type the expected Exception in the example header after the <code>throws</code> keyword. If you want to check for multiple exceptions in the same example, you can use the build in <code>expect</code> extension method. The first parameter is the type of the expected exception and the second parameter is a closure with the expression that should throw the exception.</p>
<pre class="prettyprint lang-jnario">
describe "Division"{
  fact "on division by zero"{
    val x = 1 / 0 should throw ArithmeticException
  }
  fact "throws an ArithmeticException on division by zero"{
    expect(typeof(ArithmeticException))[
      val x = 1 / 0
    ]
   }
 }</pre>
</p>
</li>
</ul>
</li>
<li><h3>Using Example Tables</h3>
<p></p>
<ul>
<li><strong>Writing Assertions</strong>
<p>
<pre class="prettyprint lang-jnario">
describe "Tables" {
  def additions{
    | a | b | sum |
    | 0 | 0 |  0  |
    | 1 | 2 |  3  |
    | 4 | 5 |  9  |
  }
  - [additions.forEach[a + b =&gt; sum]]
}</pre>
</p>
</li>
<li><strong>Specifying the Column Type [PENDING]</strong>
<p>
</li>
</ul>
</li>
<li><h3>Spec extensions</h3>
<p></p>
<ul>
</ul>
</li>
</ul>
				</div>
			</div>
		</div> <!-- /content -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>

	</div>
	<!-- /container -->

</body>
</html>
